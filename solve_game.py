# Функция проверяет условия для выигрыша Пети своим вторым ходом.
def petya_wins_on_second_move(S):
    # Если S нечётное, Петин единственный ход: m = 3 * S.
    if S % 2 == 1:
        m = 3 * S
        # Петя не выигрывает первым ходом:
        if m >= 51:
            return False
        # Ваня из m (нечётное) делает единственный ход: v = 3 * m.
        v = 3 * m
        # Если Ваня выигрывает, или если Петин следующий ход не обеспечивает выигрыш:
        if v >= 51:  # Ваня выиграет немедленно.
            return False
        # Петин следующий ход будет 3 * v; если он ≥ 51, выигрывает.
        return 3 * v >= 51
    else:
        # S чётное: Петя выбирает либо m = S + 1, либо m = S + 3 так, чтобы m удовлетворяло:
        #   m < 51 (иначе немедленная победа), m нечётное, 3*m < 51 (чтобы Ваня не выиграл),
        #   и 9*m >= 51 (Петин следующий ход обеспечивает победу).
        possible_moves = []
        for add in [1, 3]:
            m = S + add
            if m < 51 and m % 2 == 1:
                possible_moves.append(m)
        for m in possible_moves:
            if 3 * m < 51 and 9 * m >= 51:
                return True
        return False

# Ищем все S от 1 до 50, для которых Петя имеет выигрышную стратегию,
# при условии, что он не может победить первым ходом, но гарантирует победу вторым.
valid_S = [S for S in range(1, 51) if petya_wins_on_second_move(S)]
# Выбираем два наибольших значения S и выводим их в порядке возрастания.
if len(valid_S) >= 2:
    result = sorted(valid_S)[-2:]
    print(result)
else:
    print("Недостаточно значений")
    
# Если запустить этот скрипт, результат должен быть: [12, 14]
